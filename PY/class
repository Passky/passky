def __*shit(): //使shit函数 private<-一个/两个下划线皆可
class (继承的类 默认object)>
def __shit__(self,a,b): 
//特殊方法->把a,b绑定到self 通过self.a等访问 并在定义时赋值
//属性也可以用"__"开头以private ->用方法访问
也可用 ._class__name访问 
//但是__x__的特殊变量是不private的
__init__ ->函数用于初始化
>>> bart = Student('Bart Simpson', 59)
>>> bart.get_name()
'Bart Simpson'
>>> bart.__name = 'New Name' # 设置__name变量！
>>> bart.__name
'New Name'
表面上看，外部代码“成功”地设置了__name变量，但实际上这个__name变量和class内部的__name变量不是一个变量！内部的__name变量已经被Python解释器自动改成了_Student__name，而外部代码给bart新增了一个__name变量。不信试试：

>>> bart.get_name() # get_name()内部返回self.__name
'Bart Simpson'
多态要 pass||且子类可以被视作父类
动态语言不要求一定传入子类
但是静态语言要求如此
可以直接定义类属性,不用函数 ->全局
class Student(object):   //这里真的只能用slots
    __slots__ = ('name', 'age') # 用tuple定义允许绑定的属性名称
@property <-(函数名都要是xx)-> @xx(not special).setter 把get方法变成属性->只定义getter方法，不定义setter方法就是一个只读属性
decorate ⬇ 封装成attr用   ----大概可以检查参数吧