用默认参数实现参数可选!
type() ->返回对应的class类型(用等号对比) ->types模块 ->有内建定义常量判断是否为函数 types.FunctionType\BuiltinFunctionType\LambdaType\GeneratorType(循环)
isinstance(x,type)  //判断类型->继承关系
dir()->返回所有属性和方法
类似__xxx__的属性和方法在Python中都是有特殊用途的，比如__len__方法返回长度。在Python中，如果你调用len()函数试图获取一个对象的长度，实际上，在len()函数内部，它自动去调用该对象的__len__()方法，所以，下面的代码是等价的：
callable() ->是否可调用
attr ->属性
hasattr() -> exist 
setattr() -> set
getattr() -> get
del(class.attr) -> delete
__slots__  ->限制增加attr 
//在子类中无效,重新定义slots则是子类+父类
@property ->装饰器
eval(expression,globals(计算式中函数的全局命名空间),locals(局部命名空间))
expression 字符串->会被视作表达式
@xx(被装饰).setter ->把方法变成属性调用
"我们先考察如何使用。把一个getter方法变成属性，只需要加上@property就可以了，此时，@property本身又创建了另一个装饰器@score.setter，负责把一个setter方法变成属性赋值，于是，我们就拥有一个可控的属性操作：'
class Student(object):

    @property
    def score(self):
        return self._score

    @score.setter
    def score(self, value):
        if not isinstance(value, int):
            raise ValueError('score must be an integer!')
        if value < 0 or value > 100:
            raise ValueError('score must between 0 ~ 100!')
        self._score = value